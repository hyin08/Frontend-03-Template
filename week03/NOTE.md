## HTML解析
1. parser将HTML文本解析成DOM树，并单独拆成一个文件
2. 使用FSM来处理分析HTML， 根据HTML Standard已经拆分好的state进行代码编写，课件中只选取重要的状态编写，以后自己将状态补全
3. 解析时我们从标签开始入手，分为开始标签、结束标签和自封闭标签
4. 在状态机中，除了状态转移，我们还要加入业务逻辑（创建token、将字符加到token上，最后emit token）
5. 然后处理属性，分为单引号、双引号和无引号三种属性，跟处理tag类似
6. 使用栈将tag构建成DOM树
  + 遇到开始标签时创建元素并入栈，遇到结束标签时出栈
  + 自封闭节点可视为入栈后立刻出栈
  + 任何元素的父元素是它入栈前的栈顶
7. 将文本节点与自封闭标签处理类似，由于我们将每个字符当成一个文本节点emit，因此多个连续的文本节点需要合并

## CSS计算
1. 遇到style标签时，我们把CSS规则保存起来，并使用现成的CSS Parser来分析CSS规则
2. 理论上，当我们分析一个元素时，所有CSS规则已经收集完毕，所以当我们创建一个元素后，立即计算CSS。（现实中，可能遇到写在body的style标签，需要重新CSS计算）
3. 在computeCSS函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配。我们可以从上一步骤的stack，可以获取本元素所有的父元素，获得和计算父元素匹配的顺序是从内向外。
4. 选择器也要从当前元素向外排列。toyBrowser中我们假设一个复杂选择器里只包含简单选择器，暂不处理复合情况，我们将复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列。
5. 根据选择器的类型和元素属性，计算是否与当前元素匹配
6. 一旦选择匹配，就应用选择器到元素上，形成computedStyle
7. 根据specificity和后来优先规则覆盖CSS。
  + specificity是个四元组，越左边权重越高
  + 一个CSS规则的specificity根据包含的简单选择器相加而成
